---
title: "How I work with census data"
bibliography: "../../blog.bib"
author: "Peter Amerkhanian"
date: "2024-9-1"
draft: false
image: thumbnail.png
engine: knitr
categories: ['R', 'Data Management']
format:
  html:
    df-print: kable
    toc: true
    toc-depth: 3
    code-fold: false
    code-tools: true
editor: 
  markdown: 
    wrap: 72
---

```{r}
#| output: false
library(dplyr)
library(ggplot2)
library(modelsummary)
library(ggstats)
library(srvyr)

```



I often want to reference 

## Microdata via IPUMS

> IPUMS provides census and survey data from around the world integrated
> across time and space. IPUMS integration and documentation makes it
> easy to study change, conduct comparative research, merge information
> across data types, and analyze individuals within family and community
> contexts. Data and services available free of charge. -- \[\@\]


[@walker_analyzing_2023, chapter 9]

ipums r is cool

```{r}
#| output: false
library(ipumsr)
# Note -- I store my ipums api key in the .Renviron file
set_ipums_api_key(Sys.getenv("ipums_api_key"))
```

What's available?

```{r}
ipums_data_collections() %>%
  filter(api_support == TRUE) %>% 
  arrange(desc(collection_type))
```


For analysis of populations in the U.S., the IPUMS USA and IPUMS CPS collections are of particular interest:

IPUMS USA: IPUMS USA collects, preserves and harmonizes U.S. census
microdata and provides easy access to this data with enhanced
documentation. Data includes decennial censuses from 1790 to 2010 and American Community Surveys (ACS) from 2000 to the present [@ruggles_ipums_2024].

We can check out the newest products they have in the USA collection as
follows:

```{r}
get_sample_info(collection="usa") %>% arrange(desc(name)) %>% head(5)
```


```{r}
get_sample_info(collection="usa") %>%
  filter(stringr::str_detect(description, "ACS")) %>%
  arrange(desc(name)) %>%
  head(5)
```

## An IPUMS USA example

What is the median household income in Oakland, California?

I'll define a function, `retrieve_ca_sample()` that accomplishes that and only run the IPUMS request if I don't already have the data locally.

```{r}
retrieve_ca_sample <- function(sample){
  extract <- define_extract_micro(
    description = "CA Incomes by PUMA",
    collection = "usa",
    samples = c(sample),
    variables = list(
      "PUMA",
      "FAMUNIT",
      "RELATE",
      "AGE",
      "SEX",
      "EDUC",
      "POVERTY",
      "HHINCOME",
      "INCTOT",
      var_spec("STATEFIP", case_selections = "06")
    )
  )
  data_path <- extract %>%
    submit_extract() %>%
    wait_for_extract() %>%
    download_extract(download_dir = here::here("data"),
                     overwrite = TRUE)
  data <- read_ipums_micro(data_path)
  return(data)
  }
```

Now I will run the retrieval conditionally, so that if I already have the file, I don't re-download it
```{r}
local_ipums_extracts <- list.files(
  path = here::here('data'),
  pattern = "\\.xml$",
  full.names = TRUE)

if (length(local_ipums_extracts) > 0) {
  existing_path <- local_ipums_extracts[1]
  data <- read_ipums_micro(existing_path)
} else {
  data <- retrieve_ca_sample("us2022a")
}
```
### Small geographies in the ACS
Use the [2020 PUMA
Names](https://www2.census.gov/geo/pdfs/reference/puma2020/2020_PUMA_Names.pdf).


The smallest geographic area explicitly identified in the microdata is public use microdata area (PUMA), a geographic area defined based on population. Each PUMA includes about 100,000 residents. IPUMS geographers are sometimes able to infer other small geographic areas, such as city, metro area, and county, from PUMA, depending on how the boundaries of PUMAs and these other geographic areas correspond. As a result, some cities, metro areas, and counties are not able to be identified in the microdata.
https://forum.ipums.org/t/how-can-i-pull-data-at-the-zip-code-or-city-level/5650/2


```{r}
oakland_pumas <- c(111, 112, 113, 123)
oak <- data %>%
  filter(PUMA %in% oakland_pumas)
oak %>% head()
```

### Granularity and weights in the ACS

SERIAL is an identifying number unique to each household record in a given sample. All person records are assigned the same serial number as the household record that they follow. (Person records also have their own unique identifiers - see PERNUM.) 

**A combination of SAMPLE and SERIAL provides a unique identifier for every household in the IPUMS**;  
**the combination of SAMPLE, SERIAL, and PERNUM uniquely identifies every person in the database.** https://usa.ipums.org/usa-action/variables/SERIAL

```{r}
oak %>% group_by(PUMA) %>% summarise(
  n_rows = n(),
  n_individuals = n_distinct(SAMPLE, SERIAL, PERNUM),
  n_households = n_distinct(SAMPLE, SERIAL)
  )
```

Thus, `oak` is at the individual level. Here I'll make a `oak_households` dataframe that is at the household level:

```{r}
oak_households <- oak %>%
  distinct(SAMPLE, SERIAL, .keep_all = TRUE)
```

Now that I have the households-level dataset, I'll look at how we define household income:

INCTOT reports each respondent's total pre-tax personal income or losses from all sources for the previous year. The censuses collected information on income received from these sources during the previous calendar year; [...] the reference period was the past 12 months.
https://usa.ipums.org/usa-action/variables/INCTOT

HHINCOME reports the total money income of all household members age 15+ during the previous year. The amount should equal the sum of all household members' individual incomes, as recorded in the person-record variable INCTOT. https://usa.ipums.org/usa-action/variables/HHINCOME

Missing variables--  
For both INCTOT and HHINCOME,
9999999 = N/A
For INCTOT:
9999998 = Unknown



```{r}
households_w_income <- oak_households %>% 
  filter(HHINCOME != 9999999,
         HHINCOME >= 0)
```



```{r}
#| label: tbl-example-hh
#| tbl-cap: "An example household"

household_serials <- oak %>%
  group_by(SERIAL) %>%
  count() %>%
  filter(n > 1) %>%
  pull(SERIAL)
set.seed(2)

oak %>% filter(SERIAL == sample(household_serials, 1)) %>% 
  select(c(SEX, AGE, HHINCOME, INCTOT, PERWT, HHWT))
```

To apply sample weights to an IPUMS file, users should follow one of the following procedures:

1. For household-level analyses using the [...] ACS/PRCS samples, weight the households using the HHWT variable. HHWT gives the number of households in the general population represented by each household in the sample.
2. For person-level analyses using the [...] ACS/PRCS samples, apply the PERWT variable. PERWT gives the population represented by each individual in the sample.

https://usa.ipums.org/usa/intro.shtml#weights

```{r}
households_w_income <- oak_households %>% 
filter(HHINCOME != 9999999, HHINCOME > 0)

households_w_income%>% 
  select(HHINCOME) %>% summary()

households_w_income
```
```{r}
households_w_income %>%
  as_survey_design(ids = CLUSTER, weights=HHWT, strata=STRATA, nest = TRUE) %>%
  srvyr::summarize(survey_quantile(HHINCOME, c(0.5)), .name_spec='e')
```


```{r}
print(weighted.median(households_w_income$HHINCOME, households_w_income$HHWT))
```
```{r}
households_w_income %>% select(HHWT) %>% sum()
```
### Comparing results to census aggregates

I don't like the IPUMS option for getting single year data points, for that I like tidycensus

```{r}
#| output: false
#| warning: false
library(tidycensus)
# Note -- I store my census api key in the .Renviron file
census_api_key(Sys.getenv("census_api_key"))
```
I can use tidycensus to easily access aggregate measures from the census. https://walker-data.com/tidycensus/

```{r}
#| warning: false
# Retrieve poverty data for Oakland (place level)
oakland_stats <- get_acs(
  geography = "place",
  variables = c(
    median_hh_income = "B19013_001", # Median household income
    total_pop = "B17001_001"  # Total population for poverty status determination
  ),
  state = "CA",
  year = 2022,  # Adjust the year for ACS 5-year estimates
  survey = "acs1"  # Use 5-year ACS estimates
)

oakland_stats <- oakland_stats %>% filter(GEOID == '0653000')
oakland_stats
```

The public use samples of the ACS and PRCS are extracted from the Census Bureau's larger internal data files and are thus subject to additional sampling error and further data processing (such as imputation and allocation).
[...]
individual variables, such as income and housing values, are Top coded.
[...]
Weights included with the ACS PUMS for the household and person-level data adjust for the mixed geographic sampling rates, nonresponse adjustments, and individual sampling probabilities. Estimates from the ACS IPUMS samples may not be consistent with summary table ACS estimates due to the additional sampling error.

https://usa.ipums.org/usa/chapter2/chapter2.shtml#ACS

### Using microdata

Why is it coooler to get microdata?

```{r}
individuals_w_income <- oak %>%
  # Find adult earners
  filter(INCTOT != 9999999, INCTOT > 0, AGE >= 18) %>%
  # Label sex
  mutate(SEX = case_when(SEX == 1 ~ 'Male', TRUE ~ 'Female')) %>%
  # Label education
  mutate(
    educ_attain = case_when(
      EDUC == 10 ~ "Bachelor's degree",
      EDUC == 11 ~ "Graduate degree",
      EDUCD %in% c(63, 65, 64) ~ "Highschool diploma",
      EDUCD == 71 ~ "Some college",
      EDUC == 8 ~ "Associate's degree",
      EDUC == 0 ~ "No schooling",
      EDUCD == 61 ~ "Some school",
      EDUC < 6 ~ "Some school",
    ) %>% as.factor()
  )
```

```{r}
individuals_w_income %>%
  group_by(SEX) %>%
  summarise(mean_income = mean(INCTOT))
```

```{r}
99333.91 / 76766.01
```


```{r}
#| warning: false
#| code-fold: true

colors <- RColorBrewer::brewer.pal(n=5, "Set1")[c(5, 2)]

max_income <- 400000
steps <- 50000

ggplot(individuals_w_income, aes(x = INCTOT, color = factor(SEX), fill = factor(SEX), weight = PERWT)) +
  geom_histogram(binwidth = steps, position = "dodge", boundary = 0, alpha = 0.8, aes(y = ..density..)) +
  scale_color_manual(values = colors) +
  scale_fill_manual(values = colors) +
  scale_x_continuous(labels = scales::label_dollar(),
                     limits = c(0, 400000),
                     breaks = seq(0, 400000, steps)) +
  scale_y_continuous(labels = scales::label_percent(), ) +
  labs(title = "Income Distribution by Sex",
       x = "Income",
       y = "Density",
       color = "Sex",
       fill = "Sex") +
  theme(panel.grid.minor = element_blank(),
        panel.grid = element_line(color="lightgrey",
                                  size=.2,
                                  linetype = 1),
        panel.background = element_rect("white")
        )


```

```{r}
#| code-fold: true
gof_stuff <- tribble(
  ~raw, ~clean, ~fmt,
  "nobs", "N", 0,
  "r.squared", "R²", 3
)
```


```{r}
model_ols1 <- lm(log(INCTOT) ~ factor(SEX),
                 data = individuals_w_income, weights = individuals_w_income$PERWT)
model_ols2 <- lm(log(INCTOT) ~ factor(SEX) + AGE + I(AGE^2),
                 data = individuals_w_income, weights = individuals_w_income$PERWT)
model_ols3 <- lm(log(INCTOT) ~ factor(SEX) + AGE + I(AGE^2) + relevel(educ_attain, ref="Highschool diploma"),
                 data = individuals_w_income, weights = individuals_w_income$PERWT)
modelsummary(list(model_ols1, model_ols2, model_ols3),
             gof_map = gof_stuff, exponentiate = TRUE)

```





```{r}
#| warning: false
#| code-fold: true

order <- individuals_w_income %>% distinct(EDUC, educ_attain) %>% arrange(desc(EDUC)) %>% distinct(educ_attain) %>% pull()

ggplot(individuals_w_income, aes(y = factor(educ_attain, level=order), color = factor(SEX), fill = factor(SEX), weight = PERWT)) +
  geom_bar(position = "dodge", boundary = 0, alpha = 0.9, aes(x = (..count..)/sum(..count..))) +
  scale_color_manual(values = colors) +
  scale_fill_manual(values = colors) +
  scale_x_continuous(labels = scales::label_percent(), ) +
  labs(title = "Distribution of Highest Education Level by Sex",
       x = "Percent of earners",
       y = "Education",
       color = "Sex",
       fill = "Sex") +
  theme(panel.grid.minor = element_blank(),
        panel.grid = element_line(color="lightgrey",
                                  size=.2,
                                  linetype = 1),
        panel.background = element_rect("white")
        )
```

```{r}
model_ols4 <- lm(log(INCTOT) ~  AGE + I(AGE^2) + factor(SEX)*relevel(educ_attain, ref="Highschool diploma"),
                 data = individuals_w_income, weights = individuals_w_income$PERWT)
modelsummary(list(model_ols4),
             gof_map = gof_stuff, exponentiate = TRUE)
```

